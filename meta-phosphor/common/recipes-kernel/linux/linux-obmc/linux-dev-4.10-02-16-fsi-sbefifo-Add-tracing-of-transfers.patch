From patchwork Thu Feb 15 12:35:52 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [linux,dev-4.10,02/16] fsi: sbefifo: Add tracing of transfers
X-Patchwork-Submitter: Andrew Jeffery <andrew@aj.id.au>
X-Patchwork-Id: 873778
Message-Id: <20180215123606.25777-3-andrew@aj.id.au>
To: joel@jms.id.au, jk@ozlabs.org, eajames@linux.vnet.ibm.com,
 bradleyb@fuzziesquirrel.com, cbostic@linux.vnet.ibm.com
Cc: Andrew Jeffery <andrew@aj.id.au>, openbmc@lists.ozlabs.org
Date: Thu, 15 Feb 2018 23:05:52 +1030
From: Andrew Jeffery <andrew@aj.id.au>
List-Id: Development list for OpenBMC <openbmc.lists.ozlabs.org>

Signed-off-by: Andrew Jeffery <andrew@aj.id.au>
Acked-by: Eddie James <eajames@linux.vnet.ibm.com>
---
 drivers/fsi/fsi-sbefifo.c      | 16 ++++++++
 include/trace/events/sbefifo.h | 93 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 109 insertions(+)
 create mode 100644 include/trace/events/sbefifo.h

diff --git a/drivers/fsi/fsi-sbefifo.c b/drivers/fsi/fsi-sbefifo.c
index 4ac9e188e683..e15cd10bad8c 100644
--- a/drivers/fsi/fsi-sbefifo.c
+++ b/drivers/fsi/fsi-sbefifo.c
@@ -33,6 +33,9 @@
 #include <linux/uaccess.h>
 #include <linux/wait.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/sbefifo.h>
+
 /*
  * The SBEFIFO is a pipe-like FSI device for communicating with
  * the self boot engine on POWER processors.
@@ -275,6 +278,8 @@ static struct sbefifo_xfr *sbefifo_enq_xfr(struct sbefifo_client *client)
 	if (!xfr)
 		return ERR_PTR(-ENOMEM);
 
+	trace_sbefifo_enq_xfer(client, xfr);
+
 	xfr->rbuf = &client->rbuf;
 	xfr->wbuf = &client->wbuf;
 	list_add_tail(&xfr->xfrs, &sbefifo->xfrs);
@@ -303,6 +308,8 @@ static struct sbefifo_client *sbefifo_new_client(struct sbefifo *sbefifo)
 	if (!client)
 		return NULL;
 
+	trace_sbefifo_new_client(client);
+
 	kref_init(&client->kref);
 	client->dev = sbefifo;
 	sbefifo_buf_init(&client->rbuf);
@@ -343,6 +350,7 @@ static void sbefifo_release_client(struct kref *kref)
 	}
 
 	sbefifo_put(sbefifo);
+	trace_sbefifo_release_client(client);
 	kfree(client);
 }
 
@@ -393,6 +401,8 @@ static void sbefifo_poll_timer(unsigned long data)
 	if (!xfr)
 		goto out_unlock;
 
+	trace_sbefifo_begin_xfer(xfr);
+
 	rbuf = xfr->rbuf;
 	wbuf = xfr->wbuf;
 
@@ -506,6 +516,8 @@ static void sbefifo_poll_timer(unsigned long data)
 	}
 
 out:
+	trace_sbefifo_end_xfer(xfr, ret);
+
 	if (unlikely(ret)) {
 		sbefifo->rc = ret;
 		dev_err(&sbefifo->fsi_dev->dev,
@@ -612,6 +624,10 @@ static ssize_t sbefifo_read_common(struct sbefifo_client *client,
 		goto out;
 	}
 
+	trace_sbefifo_deq_xfer(client, list_first_entry_or_null(&client->xfrs,
+							   struct sbefifo_xfr,
+							   client));
+
 	n = min_t(size_t, n, len);
 
 	if (ubuf) {
diff --git a/include/trace/events/sbefifo.h b/include/trace/events/sbefifo.h
new file mode 100644
index 000000000000..4755fcb23e56
--- /dev/null
+++ b/include/trace/events/sbefifo.h
@@ -0,0 +1,93 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sbefifo
+
+#if !defined(_TRACE_TIMER_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SBEFIFO_H
+
+#include <linux/tracepoint.h>
+#include <linux/fsi-sbefifo.h>
+
+TRACE_EVENT(sbefifo_new_client,
+	TP_PROTO(const void *client),
+	TP_ARGS(client),
+	TP_STRUCT__entry(
+		__field(const void *, client)
+	),
+	TP_fast_assign(
+		__entry->client = client;
+	),
+	TP_printk("New client: %p", __entry->client)
+);
+
+TRACE_EVENT(sbefifo_release_client,
+	TP_PROTO(const void *client),
+	TP_ARGS(client),
+	TP_STRUCT__entry(
+		__field(const void *, client)
+	),
+	TP_fast_assign(
+		__entry->client = client;
+	),
+	TP_printk("Released client: %p", __entry->client)
+);
+
+TRACE_EVENT(sbefifo_enq_xfer,
+	TP_PROTO(const void *client, const void *xfer),
+	TP_ARGS(client, xfer),
+	TP_STRUCT__entry(
+		__field(const void *, client)
+		__field(const void *, xfer)
+	),
+	TP_fast_assign(
+		__entry->client = client;
+		__entry->xfer = xfer;
+	),
+	TP_printk("Client %p enqueued transfer %p",
+		  __entry->client, __entry->xfer)
+);
+
+TRACE_EVENT(sbefifo_begin_xfer,
+	TP_PROTO(const void *xfer),
+	TP_ARGS(xfer),
+	TP_STRUCT__entry(
+		__field(const void *, xfer)
+	),
+	TP_fast_assign(
+		__entry->xfer = xfer;
+	),
+	TP_printk("Began transfer %p",
+		  __entry->xfer)
+);
+
+TRACE_EVENT(sbefifo_end_xfer,
+	TP_PROTO(const void *xfer, int ret),
+	TP_ARGS(xfer, ret),
+	TP_STRUCT__entry(
+		__field(const void *, xfer)
+		__field(int, ret)
+	),
+	TP_fast_assign(
+		__entry->xfer = xfer;
+		__entry->ret = ret;
+	),
+	TP_printk("Completed transfer %p: %d",
+		  __entry->xfer, __entry->ret)
+);
+
+TRACE_EVENT(sbefifo_deq_xfer,
+	TP_PROTO(const void *client, const void *xfer),
+	TP_ARGS(client, xfer),
+	TP_STRUCT__entry(
+		__field(const void *, client)
+		__field(const void *, xfer)
+	),
+	TP_fast_assign(
+		__entry->client = client;
+		__entry->xfer = xfer;
+	),
+	TP_printk("Client %p dequeueing transfer %p",
+		  __entry->client, __entry->xfer)
+);
+#endif
+
+#include <trace/define_trace.h>
